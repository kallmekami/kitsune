#!/bin/bash

# Check if a username is provided as an argument
if [ "$#" -lt 1 ]; then
    echo "Usage: $0 <username> [service]"
    exit 1
fi

TARGET_USER="$1"
TARGET_SERVICE="$2"

# Define the log files to monitor
LOG_FILES=(
    "/var/log/syslog"
    "/var/log/auth.log"
    "/var/log/maillog"
    "/var/log/httpd/access_log"
    "/var/log/httpd/error_log"
    "/var/log/messages"
    "/var/log/secure"
    "/var/log/fail2ban.log"
)

# Define the patterns and their corresponding colors
declare -A PATTERNS=(
    ["error"]="\033[1;31m"   # Red for errors
    ["failed"]="\033[1;31m"  # Red for failures
    ["success"]="\033[1;32m" # Green for successes
    ["warning"]="\033[1;33m" # Yellow for warnings
    ["login"]="\033[1;32m"   # Green for logins
    ["logout"]="\033[1;33m"  # Yellow for logouts
)

# Function to monitor logs for a specific user and optional service
monitor_logs() {
    echo -e "\n\033[1;36m========================================\033[0m"
    echo -e "\033[1;36m           Monitoring Logs              \033[0m"
    echo -e "\033[1;36m========================================\033[0m"
    echo -e "Logs for user: \033[1;32m$TARGET_USER\033[0m"

    for LOG_FILE in "${LOG_FILES[@]}"; do
        echo -e "\n\033[1;34mChecking $LOG_FILE...\033[0m"
        
        if [[ -f $LOG_FILE ]]; then
            echo -e "\n\033[1;33m----------------------------------------\033[0m"
            echo -e "\033[1;33mUser Log Entries:\033[0m"
            echo -e "\033[1;33m----------------------------------------\033[0m"
            
            # Extract and display relevant log lines
            if [[ -n "$TARGET_SERVICE" ]]; then
                grep -i "$TARGET_USER" "$LOG_FILE" | grep -i "$TARGET_SERVICE" | grep -E "error|failed|warning|success|login|logout" | tail -n 10 | while read -r line; do
                    # Format the log line for better readability
                    timestamp=$(echo "$line" | awk '{print $1, $2, $3}')
                    log_entry=$(echo "$line" | cut -d' ' -f4-)

                    # Determine color based on content
                    if echo "$log_entry" | grep -iqE "error|failed"; then
                        echo -e "${PATTERNS["error"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "warning"; then
                        echo -e "${PATTERNS["warning"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "success"; then
                        echo -e "${PATTERNS["success"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iqE "login"; then
                        echo -e "${PATTERNS["login"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iqE "logout"; then
                        echo -e "${PATTERNS["logout"]}[$timestamp] $log_entry\033[0m"
                    else
                        echo "$line"
                    fi
                done
            else
                # If no specific service is provided, show all user-related logs
                grep -i "$TARGET_USER" "$LOG_FILE" | grep -E "error|failed|warning|success|login|logout" | tail -n 10 | while read -r line; do
                    # Format the log line for better readability
                    timestamp=$(echo "$line" | awk '{print $1, $2, $3}')
                    log_entry=$(echo "$line" | cut -d' ' -f4-)

                    # Determine color based on content
                    if echo "$log_entry" | grep -iqE "error|failed"; then
                        echo -e "${PATTERNS["error"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "warning"; then
                        echo -e "${PATTERNS["warning"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "success"; then
                        echo -e "${PATTERNS["success"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iqE "login"; then
                        echo -e "${PATTERNS["login"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iqE "logout"; then
                        echo -e "${PATTERNS["logout"]}[$timestamp] $log_entry\033[0m"
                    else
                        echo "$line"
                    fi
                done
            fi

            echo -e "\n\033[1;33m----------------------------------------\033[0m"
            if [[ -n "$TARGET_SERVICE" ]]; then
                echo -e "\033[1;33mService Log Entries for $TARGET_SERVICE:\033[0m"
                echo -e "\033[1;33m----------------------------------------\033[0m"

                # Extract relevant log lines for the specified service
                grep -i "$TARGET_SERVICE" "$LOG_FILE" | tail -n 10 | while read -r line; do
                    # Format the log line for better readability
                    timestamp=$(echo "$line" | awk '{print $1, $2, $3}')
                    log_entry=$(echo "$line" | cut -d' ' -f4-)

                    # Determine color based on content
                    if echo "$log_entry" | grep -iqE "error|failed"; then
                        echo -e "${PATTERNS["error"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "warning"; then
                        echo -e "${PATTERNS["warning"]}[$timestamp] $log_entry\033[0m"
                    elif echo "$log_entry" | grep -iq "success"; then
                        echo -e "${PATTERNS["success"]}[$timestamp] $log_entry\033[0m"
                    else
                        echo "$line"
                    fi
                done
            else
                echo -e "\033[1;33mNo specific service provided, showing all user log entries.\033[0m"
            fi
        else
            echo "Log file $LOG_FILE does not exist."
        fi
    done
}

# Function to monitor CPU, memory, and network usage for the specific user and optional service
monitor_resource_usage() {
    echo -e "\n\033[1;36m========================================\033[0m"
    echo -e "\033[1;36m       Resource Usage Monitoring        \033[0m"
    echo -e "\033[1;36m========================================\033[0m"
    printf "%-15s %-10s %-10s %-10s %-10s\n" "User" "CPU (%)" "Memory (%)" "Memory (MB)" "Net RX (KB)"
    echo "-----------------------------------------"
    
    # Get total memory in MB
    total_mem=$(grep MemTotal /proc/meminfo | awk '{print $2 / 1024}') # in MB
    
    # Get the CPU and memory usage for the specific user
    if [[ -n "$TARGET_SERVICE" ]]; then
        # If a service is specified, filter by service name
        ps -u "$TARGET_USER" -o user,%cpu,%mem,comm --sort=-%cpu | grep -i "$TARGET_SERVICE" | awk -v total_mem="$total_mem" '{
            mem_mb = ($3 * total_mem / 100);
            # Here we calculate the network RX using ss command
            cmd="ss -p | grep " $4 " | awk '\''{print $6}'\''"
            cmd | getline net_rx;
            close(cmd);
            net_rx_kb = (net_rx == "" ? 0 : net_rx / 1024); # Convert to KB
            printf "%-15s %-10.2f %-10.2f %-10.2f %-10.2f\n", $1, $2, $3, mem_mb, net_rx_kb;
        }'
    else
        # If no service specified, show all user processes
        ps -u "$TARGET_USER" -o user,%cpu,%mem --sort=-%cpu | awk -v total_mem="$total_mem" 'NR>1 {
            mem_mb = ($3 * total_mem / 100);
            cmd="ss -p | grep " $4 " | awk '\''{print $6}'\''"
            cmd | getline net_rx;
            close(cmd);
            net_rx_kb = (net_rx == "" ? 0 : net_rx / 1024); # Convert to KB
            printf "%-15s %-10.2f %-10.2f %-10.2f %-10.2f\n", $1, $2, $3, mem_mb, net_rx_kb;
        }'
    fi
}

# Run the functions
monitor_logs
monitor_resource_usage
